import numpy as np

def es_pot(self, position):
    """
    Return the electorstatic potential generated by this Mol

    Parameters
    ----------
    position : 3x1 np array
        The point at which the potential should be evaluated
    Returns
    -------
    tot_pot : float
        The total potential

    """
    tot_pot = 0
    for atom in self:
        tot_pot += atom.es_pot(position)
    return tot_pot


def change_charges(self, charges):
    """
    Change all of the charges of the constituent atoms at once

    Parameters
    ----------
    charges : array-like of floats
        Contains all of the new charges. IMPORTANT: they need to be in the
        order corresponding to self.atoms

    """
    for i, atom in enumerate(self.atoms):
        atom.q = charges[i]
    return


def charges(self):
    """Return an array of charges"""
    l_char = []
    for atom in self.atoms:
        l_char.append(atom.q)
    arr_char = np.array(l_char)
    return arr_char


def raw_assign_charges(self, charges):
    """Assign the charges from an array-like to the atoms"""
    for char, at in zip(charges, self.atoms):
        at.q = char
    return


def populate(self, reference_mol):
    """
    Assign charges to the Mol by comparing to the connectivity of a
    reference

    Parameters
    ----------
    reference_mol : Mol object
        Charged molecule or cell

    """
    # This is a naughty in-function import to prevent a circular dependency.
    # The reason is that assign_charges functions are grouped up with the
    # executable script which needs to read_file and in turn use mol.py
    # Some careful refactoring should fix this
    import fromage.scripts.fro_assign_charges as ac
    ac.assign_charges(reference_mol, self)
    pass

def set_connectivity(self):
    """Set the connectivity of all atoms in the Mol"""
    import fromage.scripts.fro_assign_charges as ac
    cnct_mat = ac.get_connectivity_mat(self)
    for i, atom in enumerate(self):
        atom.set_connectivity(self, cnct_mat[i])
    return
